name: Dan Doel
date: '2010-10-02 12:44:11'
url: ''
message: "<a href=\"http://code.haskell.org/~dolio/agda-share/html/DC.html\" rel=\"nofollow\">Here</a> is the result of some messing with Agda based on the article.\r\n\r\nThe shift/reset monad has a constructor\r\n<code>\r\nshft : ?{B} ? ((B ? R) ? R) ? (B ? Cont R A) ? Cont R A\r\n</code>\r\n\r\nwhich is, of course, conspicuously close to your $R^{R^B} \\times C^B \\to C$, renaming some variables. The fact that the captured continuation has type (B ? R) of course means that no control effects escape from it, and that the block produces a R means the same thing, although that puts the burden of enforcement on the caller of the operation, instead of the operation itself. Another possibility is ((B ? R) ? Cont R R).\r\n\r\nI also have a monad for control/prompt. It requires a negative type definition, though. The fact that the operation has changed to ((B ? Cont R R) -&gt; R) indicates that control effects can escape from calls to the continuation. Here we see the function passed to control taking responsibility for delimiting itself. To avoid this, we could make the change I mentioned, and then change the running functions to:\r\n<code>\r\n...\r\nreset (shft f k) = reset (f (? x ? reset (k x)))\r\n\r\n...\r\nprompt (ctrl f k) = prompt (f k)\r\n</code>\r\n\r\nIs this all close to what's happening in eff?\r\n\r\nPresenting the continuations this way, entering and exiting the monad, is actually kind of interesting. When every operation stays in the monad, you get constructions like:\r\n<code>\r\ndata Iterator (M : Set -&gt; Set) (A : Set) : Set where\r\n  done  : Iterator M A\r\n  yield : A -&gt; (? -&gt; M (Iterator M A)) -&gt; Iterator M A\r\n\r\niterate : {A : Set} -&gt; T A -&gt; CC (Iterator CC A)\r\niterate t = reset (for_ t (\\x -&gt; shift (\\k -&gt; pure (yield x k))) &gt;&gt; pure done)\r\n</code>\r\n\r\nfor inverting the control of a traversal. With the presentation above, though, this turns into:\r\n<code>\r\ndata Iterator (A : Set) : Set where\r\n  done  : Iterator A\r\n  yield : A -&gt; (? -&gt; Iterator A) -&gt; Iterator A\r\n\r\niterate : {A : Set} -&gt; T A -&gt; Iterator A\r\niterate t = reset (for_ t (\\x -&gt; shift (\\k -&gt; yield x k)) &gt;&gt; pure done)\r\n</code>\r\n\r\nwhich is clearly just using the traversal to produce a (lazy) list."
email: af6ee853a79ce70a9ce68ae1e1fc852c
