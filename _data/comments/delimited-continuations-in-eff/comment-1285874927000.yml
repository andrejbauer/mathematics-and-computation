name: Dan Doel
date: '2010-09-30 21:28:47'
url: ''
message: "Oleg Kiselyov et al. published a paper a while back that uses delimited continuations with multiple prompts to implement dynamically allocatable (similar to ST), dynamically scoped references. You can see an implementation <a href=\"http://hackage.haskell.org/packages/archive/CC-delcont/0.2/doc/html/Control-Monad-CC-Dynvar.html\" rel=\"nofollow\">here</a>.\n\nAs for delimited continuation monads, the method I've typically seen of getting shift and reset into the normal Cont monad is:\n<pre>\nnewtype Cont r a = Cont ((a -&gt; r) -&gt; r)\n\nrunCont :: (a -&gt; r) -&gt; Cont r a -&gt; r\nrunCont k (Cont f) = f k\n\ninstance Monad (Cont r) where\n    return x = Cont ($x)\n    Cont f &gt;&gt;= g = Cont $ \\k -&gt; f $ runCont k . g\n\nreset :: Cont a a -&gt; Cont r a\nreset m = return (runCont id m)\n\nshift :: ((a -&gt; b) -&gt; Cont b b) -&gt; Cont b a\nshift f = Cont $ \\k -&gt; runCont id $ f k\n</pre>\n\nThis can also be embellished upon, by using indexed monads. The advantage there is that the shift and reset operations can be put in a type class (the changing 'r' parameter in the normal Cont makes that not an option):\n\n<pre>\nnewtype ICont r o a = ICont ((a -&gt; o) -&gt; r)\n\nrunICont :: (a -&gt; o) -&gt; ICont r o a -&gt; r\nrunICont k (ICont f) = f k\n\nireturn :: a -&gt; ICont r r a\nireturn x = ICont ($x)\n\n(&gt;&gt;=) :: ICont r1 r2 a -&gt; (a -&gt; ICont r2 r3 b) -&gt; ICont r1 r3 b\nICont f &gt;&gt;= g = ICont $ \\k -&gt; f $ runICont k . g\n\nireset :: ICont r1 r2 r2 -&gt; ICont r3 r3 r1\nireset m = ireturn (runICont id m)\n\nishift :: ((a -&gt; b) -&gt; ICont r1 r2 r2) -&gt; ICont r1 b a\nishift f = ICont $ \\k -&gt; runICont id $ f k\n</pre>\n\nThese don't look quite like what you have above, though. Both shift and reset look like handlers of some kind.\n\nThat actually brings up another issue: delimited continuations permit you to reset anywhere for a particular prompt. I should be able to do stuff like:\n<pre>\nreset (shift (\\k -&gt; reset (shift (\\l -&gt; 0)) + (k 5)) + 1)\n</pre>\n\nAll with a single prompt. With shift and reset, control effects are unable to escape the captured continuation, so combined with multiple prompts, it may not be a big deal (although you still have to keep track of which prompt you should be shifting to in which scope manually). But there are other delimited control operators where the captured continuation can itself have control effects (that may actually be true in your eff implementation, too). control/prompt is such a set, and so:\n\n[sourcecode gutter=\"false\"]\nprompt (control (\\k -&gt;         k 5  + 1) + control (\\l -&gt; 0)) = 0\nprompt (control (\\k -&gt; prompt (k 5) + 1) + control (\\l -&gt; 0)) = 1\n</pre>\n\n(verified using CC-delcont above; this, of course, assumes left-to-right evaluation order).\n\n(Hopefully I haven't totally screwed up the formatting of this comment.)"
email: af6ee853a79ce70a9ce68ae1e1fc852c
