name: Matija Pretnar
date: '2012-03-22 12:49:50'
url: 'http://matija.pretnar.info'
message: "For comodels, observe the \"real-world\" effectful behaviour of operations:\r\n1. <code>write</code> takes a string, writes it out, and yields a unit value,\r\n2. <code>read</code> takes a unit value, reads a string, and yields it,\r\n3. <code>random_int</code> (say) takes integer bounds, generates a random integer according to the state of the pseudo-random generator, sets the new state, and yields the generated integer.\r\nIn general, an operation $op : A \\to B$ takes a parameter of type $A$, interacts with the \"real-world\", and yields a result of type $B$.\r\n\r\nIf you take $W$ to be the set of all possible worlds, operations correspond to maps $A \\times W \\to B \\times W$ â€“ they take the parameter and the current world state, and yield a result and the new world state. And this is exactly what comodels for a given collection of operations are: sets $W$ equipped with a map $A \\times W \\to B \\times W$ for each operation $op : A \\to B$. As a bonus, comodels are dual to models and thus a natural extension of the algebraic theory of effects.\r\n\r\nComodels are dubbed resources in eff and are implemented slightly differently. The main reason is that there is, of course, no datatype you can use to represent the set of all worlds $W$. For this reason, I was at first inclined to drop any explicit mention of $W$. Instead, only special built-in effects (for example standard I/O channel) would have resources and those resources would be implemented in effectful OCaml code, making $W$ implicit. Andrej argued that a programmer would still want to write her own resources, for example to implement a pseudo-random number generator. Thus, we decided to equip each resource with a state only it can access, and provided a syntax with which a programmer defines the desired behaviour."
email: 81edd40c675051c393c53f72b7c1428a
