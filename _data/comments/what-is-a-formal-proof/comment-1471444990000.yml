name: GÃ¼nter Rote
date: '2016-08-17 16:43:10'
url: ''
message: "I am missing a distinction between\n<ol>\n\t<li>Proof assistants and\n</li>\n\t<li>The formal system on which they are based on the one hand, and\n</li>\n\t<li>What can be done in principle, and\n</li>\n\t<li>What is done in practice, on the other hand.\n</li>\n</ol>\n\n\nProof assistants are great tools in <em>finding</em> (or helping to find) formal proofs, and where would we be without them? The task that they do is by nature not computable/decidable. To \"save\" the proof, it makes sense to record\nenough of the hints that were given to the system so that the program can recreate the proof next time (reproducibility). But these saved hints and intermediate steps ARE NOT the formal proof in the strict sense, they are only an implicit representation of it. The formal proof consists of the sequence of elementary steps in the underlying formal system. (Apparently it is called a derivation tree in Coq.) This is the formal proof. *In principle*, it can be printed out, and correctness can be checked trivially \"by pencil and paper\". Most formal systems have simple deduction rules that fit on one page, so there is no issue of decidability of this checking task, a checking that is of course rather delegated to a simple computer program (an \"independent checker/verifier\").\nIt is true that, in practice, no-one would want to look at formal proofs, but that is another matter. And why shouldn't a computer examine a formal proof for bugs? Andrey you write that \"Complete proofs are too big to be communicated\". So on the one hand you share the notion of a \"complete proof\". On the other hand, I am questioning whether the proofs are indeed so big, and computer memory and storage is indeed so limited these days.\n\nI have only (very limited) experience with Isabelle and HOL-type systems. Still I would strongly advocate the principle that formal proofs should not just be decidable, but trivially decidable in linear time. I am not comfortable with having to trust some single software for the correctness of my proofs. This is especially acute since the very point of having formally verified proofs is to avoid the errors that I might otherwise make. (Mike Shulman in his comment https://golem.ph.utexas.edu/category/2016/08/what_is_a_formal_proof.html#c050826 does mention bugs but he downplays their role.)\n[As a side remark, let me recount an incident, which is only weakly related: One of my students proved a nonlinear inequality by typing it into Mathematica, and it returned \"True\". I forgot which Mathematica function he used. I took me some effort to convince him that this was not an appropriate \"proof\" for inclusion into his thesis.]\n\nEvery formal proof system should (in the long run) be able to output a simple\n\"proof object\" that can be independently verified.\n\n(I was actually quite disappointed when I first found out that few systems can do it.) Maybe it works only for small proofs. \"Modularizing\" large proofs to make them manageable would thus be an interesting research project (much as we structure our hand-written proofs into lemmas). Andrey writes about formal proofs that \"little or nothing is gained by storing them or re-verifying their complete forms.\" Yes, we gain (A) confidence: Let the (complicated) system that produced the proof be buggy; as long as the verifier accepts the proof, this particular proof is fine. (I am preaching the benefits of \"Certified Computing\".)\n(B) As a side benefit, we might gain interoperability between different proof systems.\n\nThe OpenTheory  project is a step in this direction. Among other things, it includes a file format for HOL-type proofs, and anybody can write an independent checking program for its proofs in a few days."
email: b54b65b0004307f1314ad51c2f408045
