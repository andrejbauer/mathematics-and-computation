name: Matt Oliveri
date: '2016-08-25 08:21:24'
url: ''
message: "&gt; Independently, I am arguing that proof scripts are not \"Proof objects\"...\n\nSuppose it was formally proven, once and for all, by a machine-checked software verification held to any standard of rigor of your choice, that a certain LCF-style kernel for a proof checker never accepts a statement as a theorem unless it's formally provable (in the logic implemented by the proof checker). Would you still want that kernel to output the kind of dirt-simple proof object you're talking about? Would you conclude, as I would, that theorems accepted by this system are as rock-solid as we can hope for? Keep in mind that you can ask this system to rerun the proof as many times as you want, on as many machines as you want, in order to shrink the possibility of a false theorem due to chance hardware failures.\n\n(So that was two different questions just now.)\n\n&gt; “we look at what is actually going on”: I though this blog post was about criteria that formal proofs *should* satisfy, rather than *describing* the state of affairs? ;-) Anyway, this seems to be the main argument against requiring proof objects that are independently checked, that it does not conform to common practice.\n\nThat may or may not be Andrej's argument; it's definitely not mine. I currently consider a formally verified LCF-style system with a search/check-time phase distinction to be ideal. That's what it *should* be, and it's *not* the way it is now.\n\n&gt; If I would like to use a proof system whose proofs I can independently check, which systems would you recommend?\n\nYou should take a look at Dedukti. You configure it with a logic to check by giving it a signature in a fixed logical framework, and it checks proof terms for that logic. It seems there is/was a serious effort to extend various proof assistants to generate Dedukti-checkable proof terms.\n\nDedukti's proof terms may not meet your standard for proof objects though: traces of reductions are not recorded explicitly, so checking a small proof term can involve an arbitrarily-large amount of computation, depending on the signature.\n\nPlain old Edinburgh LF (another logical framework) terms are a good proof object format, because the reduction rules are fixed, and computationally very limited. Object language reductions (if there are any) have to be recorded explicitly. But I don't know of much work to have proof assistants generate LF proof terms. There <i>was</i> an extremely minimal checker for LF, implemented with &lt; 1000 lines of C. (And half of that was parser!)\n\nhttp://www.cs.princeton.edu/~appel/papers/flit.pdf\n\n&gt; Two more items about “what is actually going on”...\n\na) It'd be even nicer if the external proof tool would give Isabelle an efficient tactic script. That is probably asking too much though, since Isabelle is not the only proof assistant in the world. If proof terms win over proof scripts, it will probably be because they would turn out to be easier to standardize.\n\nb) This is reasonable, because automated provers will probably be used as external tools by proof assistants. Their purpose is not to check a proof, but to produce a proof to check. (This is also the purpose of the search-time phase, in my proposal. Indeed, external tools should only be invoked at search time, and their witnesses used for check time.)"
email: 66cbd251bde282eb2e1584080e3604ea
