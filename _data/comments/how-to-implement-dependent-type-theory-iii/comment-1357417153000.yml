name: Kir
date: '2013-01-05 21:19:13'
url: ''
message: "I'm implementing an explicitly substituting lambda-calculus in form of self-rewriting tree. The goal is to make almost everything (module loading, function definition, program parsing + desugaring) on the core var-val-fun-app language.\r\n\r\nAs Ali say, there are no unbounds (and the funarg-problem with tail-rec optimization doesn't exist too) - but I will disagree about shifts: I cannot imagine what to do with \"(//0 1) (/0)\". Being reduced, it becomes \"(/ (/0) 0)\" and we need to perform real or virtual shifting to distinct these pointers-at-zero.\r\n\r\nI want to ask, is there any significant difference between de Brujin indices and named bindings? Seems like in both cases we use distinct tokens (ints and strings) to determine, which hole suits for this value, but in case of names we need no shift at all.\r\n\r\nBy the way, does anyone know any method to optimize explicit substitution other that store at every tree node a set of not-yet-bound varnames?"
email: 07531356cc096dc9551e1ac5983f651d
