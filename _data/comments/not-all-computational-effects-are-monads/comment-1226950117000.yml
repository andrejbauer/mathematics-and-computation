name: luqui
date: '2008-11-17 20:28:37'
url: 'http://lukepalmer.wordpress.com'
message: "The boring way to do it is to make Timeout a = Integer -&gt; Integer\r\n-&gt; (Maybe a, Integer), or in Haskell nomenclature, \r\nTimeout a = MaybeT (ReaderT Integer (State Integer)) a.  The idea being\r\nthat tick checks the current counter against a maximum and returns\r\nNothing if it's too big.\r\n\r\nBut that's complicated.  The fun way to do it is with lazy naturals.\r\nJust define:\r\n\r\n\r\ndata Nat = Z | S Nat\r\n\r\ngreaterThan :: Nat -&gt; Integer -&gt; Bool\r\ngreaterThan Z _ = False\r\ngreaterThan (S _) 0 = True\r\ngreaterThan (S n) m = greaterThan n (m-1)\r\n\r\n\r\nAnd standard addition, then define Timeout just how you did in your\r\npost.  The timeout function is then:\r\n\r\n\r\ntimeout :: Integer -&gt; Timeout a -&gt; Maybe a\r\ntimeout n a = let Ticks (k,v) = a in\r\n              if k `greaterThan` n then Nothing else Just v\r\n\r\n\r\nAnd all the examples work fine :-).  The Haskellian way to do it is to\r\ndefine Nat as a Monoid under addition then use the Writer monad.  Same\r\ndiff.\r\n\r\nOh, and I wouldn't have defined return = tick, because it violates a\r\nmonad law."
email: 08727b23ba62e634b32988cdff082663
