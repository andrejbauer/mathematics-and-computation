name: luqui
date: '2008-11-17 20:28:37'
url: 'http://lukepalmer.wordpress.com'
message: "The boring way to do it is to make Timeout a = Integer -&gt; Integer\n-&gt; (Maybe a, Integer), or in Haskell nomenclature, \nTimeout a = MaybeT (ReaderT Integer (State Integer)) a.  The idea being\nthat tick checks the current counter against a maximum and returns\nNothing if it's too big.\n\nBut that's complicated.  The fun way to do it is with lazy naturals.\nJust define:\n\n\ndata Nat = Z | S Nat\n\ngreaterThan :: Nat -&gt; Integer -&gt; Bool\ngreaterThan Z _ = False\ngreaterThan (S _) 0 = True\ngreaterThan (S n) m = greaterThan n (m-1)\n\n\nAnd standard addition, then define Timeout just how you did in your\npost.  The timeout function is then:\n\n\ntimeout :: Integer -&gt; Timeout a -&gt; Maybe a\ntimeout n a = let Ticks (k,v) = a in\n              if k `greaterThan` n then Nothing else Just v\n\n\nAnd all the examples work fine :-).  The Haskellian way to do it is to\ndefine Nat as a Monoid under addition then use the Writer monad.  Same\ndiff.\n\nOh, and I wouldn't have defined return = tick, because it violates a\nmonad law."
email: 08727b23ba62e634b32988cdff082663
