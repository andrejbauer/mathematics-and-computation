name: Martin EscardÃ³
date: '2008-11-19 19:24:57'
url: 'http://www.cs.bham.ac.uk/~mhe/'
message: "I wrote a note (in 1998) that considers ticks, and has a monad for that.\n\nhttp://www.cs.bham.ac.uk/~mhe/papers/metricpcf.pdf\n\nI would define, in Haskell, corresponding to the above note, \n\ndata T a = Stop a | Delay(T a)\n\ninstance Monad T where\n  return = eta\n  xs &gt;&gt;= f = mu(t f xs)\n\neta :: a -&gt; T a\neta x = Stop x\n\nmu :: T(T a) -&gt; T a\nmu(Stop xs) = xs\nmu(Delay xss) = Delay(mu xss)\n\nt :: (a -&gt; b) -&gt; (T a -&gt; T b)\nt f (Stop x) = Stop(f x)\nt f (Delay xs) = Delay(t f xs)\n\ntimeout :: Int -&gt; T a -&gt; Maybe a\ntimeout n (Stop x) = Just x\ntimeout 0 (Delay xs) = Nothing\ntimeout (n+1) (Delay xs) = timeout n xs\n\ntimeof :: T a -&gt; Int\ntimeof (Stop x) = 0\ntimeof (Delay xs) = 1 + timeof xs\n\ntimedRecursion :: (T a -&gt; T a) -&gt; T a\ntimedRecursion f = Delay (f (timedRecursion f))\n\nThe last one ticks once for each recursion unfolding. Notice the similarity (and difference) with lazy natural numbers. But, as the paper discusses, it is perhaps more sensible, in a call-by-name language, to tick only at ground types. Then you define, by induction on types, a new delay function (starting with delay=Delay at ground types) pointwise. The paper proves some properties of this. \n\nNotice that an infinite computation returns, rather than bottom, infty, where\n\ninfty = Delay infty.\n\nThe output type of timeof can of course (and sensibly) be replaced by the lazy natural numbers."
email: f744e9626423ff7587e25a41c2f682de
