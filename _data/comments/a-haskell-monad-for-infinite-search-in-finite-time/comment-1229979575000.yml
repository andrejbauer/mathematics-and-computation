name: migmit
date: '2008-12-22 21:59:35'
url: ''
message: "It's really nice, but I think it can be slightly improved.\n\nI'll use \"r\" instead of \"Bool\" for the return type, since it really works for any type.\n\nInstead of (a -&gt; r) -&gt; a, we can use (a -&gt; r) -&gt; (r -&gt; a). Semantically, given a \"predicate\" of type a -&gt; r, and a value of type r, this function would look for an element x :: a, such that this predicate, applied to x, results in a given value.\n\nYour invariant for the function find :: S a -&gt; (a -&gt; Bool) -&gt; a is the following: if there is x such that f x == True, then f (find xs f) == True.\n\nMy invariant is: if there is x such that f x == y, then f (find xs f y) == y; this can be written as f (find xs f (f x)) = f x (without conditions), or, more nicely, f . find xs f . f = f, which looks algebraically nice.\n\nNow, your \"image\" is just \"liftM\", \"bigUnion\" is just \"join\", \"times\" is \"liftM2 (,)\", and the Monad instance can be defined straigtforwardly:\n\ninstance Monad (S r) where\n    return x = S (\\_ _ -&gt; x)\n    xs &gt;&gt;= f =\n        S $ \\yp z -&gt;\n            let try x = find (f x) yp z\n                x0 = find xs (yp . try) z\n            in try x0\n\nThe fun part, I think, is a definition of \"union\":\n\nxs1 `union` xs2 =\n    do b  bp True == b)\n\nThat's just minor remarks, though."
email: 98791baaf25f01c4cd5dd8385a14966d
