name: migmit
date: '2008-12-22 21:59:35'
url: ''
message: "It's really nice, but I think it can be slightly improved.\r\n\r\nI'll use \"r\" instead of \"Bool\" for the return type, since it really works for any type.\r\n\r\nInstead of (a -&gt; r) -&gt; a, we can use (a -&gt; r) -&gt; (r -&gt; a). Semantically, given a \"predicate\" of type a -&gt; r, and a value of type r, this function would look for an element x :: a, such that this predicate, applied to x, results in a given value.\r\n\r\nYour invariant for the function find :: S a -&gt; (a -&gt; Bool) -&gt; a is the following: if there is x such that f x == True, then f (find xs f) == True.\r\n\r\nMy invariant is: if there is x such that f x == y, then f (find xs f y) == y; this can be written as f (find xs f (f x)) = f x (without conditions), or, more nicely, f . find xs f . f = f, which looks algebraically nice.\r\n\r\nNow, your \"image\" is just \"liftM\", \"bigUnion\" is just \"join\", \"times\" is \"liftM2 (,)\", and the Monad instance can be defined straigtforwardly:\r\n\r\ninstance Monad (S r) where\r\n    return x = S (\\_ _ -&gt; x)\r\n    xs &gt;&gt;= f =\r\n        S $ \\yp z -&gt;\r\n            let try x = find (f x) yp z\r\n                x0 = find xs (yp . try) z\r\n            in try x0\r\n\r\nThe fun part, I think, is a definition of \"union\":\r\n\r\nxs1 `union` xs2 =\r\n    do b  bp True == b)\r\n\r\nThat's just minor remarks, though."
email: 98791baaf25f01c4cd5dd8385a14966d
