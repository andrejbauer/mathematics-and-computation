name: Martin Escardo
date: '2007-10-01 16:28:45'
url: 'http://www.cs.bham.ac.uk/~mhe/'
message: "I've found a way of making the fastest algorithm about 40 faster by avoiding the trees and instead treating functions as trees:\n\n<pre>&gt; find = find_viii\n&gt; findBit :: (Bit -&gt; Bool) -&gt; Bit\n&gt; findBit p = if p Zero then Zero else One\n&gt; branch :: Bit -&gt; Cantor -&gt; Cantor -&gt; Cantor\n&gt; branch x l r n |  n == 0    = x\n&gt;                    |  odd n     = l ((n-1) `div` 2)\n&gt;                    |  otherwise = r ((n-2) `div` 2)\n&gt; find_viii :: (Cantor -&gt; Bool) -&gt; Cantor\n&gt; find_viii p = branch x l r\n&gt;  where x = findBit(\\x -&gt; forsome(\\l -&gt; forsome(\\r -&gt; p(branch x l r))))\n&gt;          l = find_viii(\\l -&gt; forsome(\\r -&gt; p(branch x l r)))\n&gt;          r = find_viii(\\r -&gt; p(branch x l r))\n\n</pre>This doesn't need the memoization, because the things one needs to remember are bound to variables in the where-clause. Using this algorithm, comparing f' and g', and f' and h' for equality moves from 6.75 and 3.20 seconds to respectively 0.14 and 0.09 seconds (using the Glasgow interpreter in all cases).\n"
email: f744e9626423ff7587e25a41c2f682de
