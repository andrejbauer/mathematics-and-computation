name: Dan Doel
date: '2012-01-20 21:17:08'
url: ''
message: "The ack example can be given types in the polymorphic lambda calculus that will allow it to do the right thing, too.\n\none : forall r. (r -&gt; r) -&gt; r -&gt; r\nsuc : (forall r. (r -&gt; r) -&gt; r -&gt; r) -&gt; (forall r. (r -&gt; r) -&gt; r -&gt; r)\nack : (forall r. (r -&gt; r) -&gt; r -&gt; r) -&gt; (forall r. (r -&gt; r) -&gt; r -&gt; r) -&gt; (forall r. (r -&gt; r) -&gt; r -&gt; r)\n\nAlso, the ack definition makes essential use of Nat (= forall r. (r -&gt; r) -&gt; r -&gt; r) being a first class type. If we put in expicit instantiations:\n\nack m = m (Nat -&gt; Nat) (\\(f : Nat -&gt; Nat) (n : Nat) -&gt; n Nat f (f one)) suc\n\nFor one, we eliminate m over Nat -&gt; Nat, but that's not an insurmountable problem. The problem is the \\f n -&gt; n f (f 1) expression. That is the suc case, so we take f : T -&gt; T, and use it to produce a T -&gt; T. We start by abstracting over n, which must have type T. Then, we need to eliminate n as a natural using f as the successor function. This means that n : (T -&gt; T) -&gt; T -&gt; T. So we need T ~ (T -&gt; T) -&gt; T -&gt; T, but this is impossible without recursive types or an encoding thereof. System F can handle it using impredicativity, and the untyped lambda calculus can handle it because it just doesn't care, but simple types are going to fall down, and not allow you to call ack with the values you want.\n\nMaybe it's possible to do similar tricks to multiplication. That is:\n\n    m * n = m Nat (n +) 0\n\nisn't available, but:\n\n    (m * n) R s z = m R (n R s) z\n\nis. But I couldn't come up with an obvious variation of your above code that qualified."
email: af6ee853a79ce70a9ce68ae1e1fc852c
