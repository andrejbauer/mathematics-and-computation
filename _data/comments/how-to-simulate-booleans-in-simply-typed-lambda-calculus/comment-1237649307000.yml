name: jeremy
date: '2009-03-21 16:28:27'
url: ''
message: "I don't know whether this is the solution you're after, but it seems to be possible to define cond_t inductively over types. The grammar of types is \r\n<blockquote><pre>t ::= O | t -&gt; t | t * t</pre></blockquote>\r\nNow we can define\r\n<blockquote><pre>   Boolean = Base -&gt; Base -&gt; Base\r\n   true  = \\(k1 :: Base) -&gt; \\(k2 :: Base) -&gt; k1\r\n   false = \\(k1 :: Base) -&gt; \\(k2 :: Base) -&gt; k2</pre></blockquote>\r\nand cond at type t by the function [[-]] where (using a Haskelly\r\nnotation)\r\n<blockquote><pre>   [[O]] = \\(c::Boolean) -&gt; c\r\n   [[t1 -&gt; t2]] = \\(c :: Boolean) -&gt; \\(k1 :: t1) -&gt; \\(k2 :: t2) -&gt; \r\n                  \\(x::t1) -&gt; [[t2]] c (k1 x) (k2 x)\r\n   [[t1 * t2]] = \\(c :: Boolean) -&gt; \\(k1 :: t1*t2) -&gt; \\(k2 :: t1*t2) -&gt;\r\n                  ([[t1]] c (fst k1) (fst k2), [[t2]] c (snd k1) (snd k2))</pre></blockquote>\r\nNow we have a single definition of Boolean and we can obtain cond_t\r\nfor any particular t. In fact, we can define cond in Haskell using GADTs:\r\n<blockquote><pre>{-# LANGUAGE EmptyDataDecls,PatternSignatures,GADTs,KindSignatures,ScopedTypeVariables #-}\r\n\r\ndata Base\r\n\r\ndata Type :: * -&gt; * where\r\n     Base  :: Type Base\r\n     (:-&gt;) :: Type a -&gt; Type b -&gt; Type (a -&gt; b)\r\n     (:*)  :: Type a -&gt; Type b -&gt; Type (a, b)\r\n\r\ntype Boolean = Base -&gt; Base -&gt; Base\r\n\r\ntrue :: Boolean\r\ntrue = \\(k1 :: Base) -&gt; \\(k2 :: Base) -&gt; k1\r\n\r\nfalse :: Boolean\r\nfalse = \\(k1 :: Base) -&gt; \\(k2 :: Base) -&gt; k2\r\n\r\ncond :: Type t -&gt; Boolean -&gt; t -&gt; t -&gt; t\r\ncond Base = \\(c::Boolean) -&gt; c\r\ncond ((t1 :: Type t1) :-&gt; (t2 :: Type t2)) =\r\n    \\(c::Boolean) -&gt; \r\n    \\(k1 :: t1 -&gt; t2) -&gt;\r\n    \\(k2 :: t1 -&gt; t2) -&gt; \r\n    \\(x :: t1) -&gt;\r\n        cond t2 c (k1 x) (k2 x) \r\ncond ((t1 :: Type t1) :* (t2 :: Type t2)) = \r\n    \\(c::Boolean) -&gt;\r\n    \\(k1 :: (t1, t2)) -&gt;\r\n    \\(k2 :: (t1, t2)) -&gt;\r\n        (cond t1 c (fst k1) (fst k2), \r\n         cond t2 c (snd k1) (snd k2))</pre></blockquote>\r\n"
email: 1a22832368217941397442baeaec3152
