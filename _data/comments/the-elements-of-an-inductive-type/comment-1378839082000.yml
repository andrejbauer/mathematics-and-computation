name: Peter LeFanu Lumsdaine
date: '2013-09-10 20:51:22'
url: ''
message: "@Jesse: as @Mike said, we discussed this a bit last year, and it definitely seems like a fun question where there’s a lot to be worked out!\r\n\r\nIn all the versions of it we considered, though, the condition that the functor preserves the terminal object was essential — or at least, it must be *consistent* that the functor preserves the terminal object, since the new inductive type will allow one to prove that it does.\r\n\r\nFor instance, in your <code>pInductive Ghostly := spectre : 1 + Ghostly.</code> what elimination principle were you thinking of?  If it’s analogous to the familiar cases, and implies that <code>Ghostly</code> is an initial “type <code>X</code> with a point of <code>(1 + X)</code>” then this is inconsistent. Taking any type <code>Y</code>, equipped with the adjoined point <code>inl tt</code> of <code>1+Y</code>, we get a map <code>f : Ghostly -&gt; Y</code>, such that <code>(1+f) spectre = inl tt</code>; this implies that <code>spectre = inl tt</code>.  Conversely, taking any inhabited type <code>y0 : Y</code>, we get <code>f</code> such that <code>(1+f) spectre = inr y0</code>; but this implies that <code>spectre ? inl tt</code>.\r\n\r\nIn general, this sort of problem arises whenever the free element gives us “new information” — in this case, the information of whether <code>spectre</code> lies in the left or right half of the coproduct.  More precisely, if we have a type <i>X</i> with a free element <i>x0</i> of <i>G(X)</i> in the above sense, then an argument like the above implies that <i>G(1) = 1</i>: given any element of <i>G(1)</i>, there’s a map <i>f : X -&gt; 1</i> such that <i>G(f)</i> sends <i>x0</i> to that element; but there’s only one possible such map, so all elements of <i>G(1)</i> must be equal."
email: aa7788c6e710db4ca184114e527a9c54
