name: Sebastian Morawietz
date: '2009-04-12 19:07:41'
url: 'http://twitter.com/flitzwald'
message: "It wasn't and isn't my intention to be impolite. Sorry, if my previous comment was perceived this way. \r\nBut to be perfectly clear: I read your essay, I understood your points (I guess) and I thoroughly disagree. Furthermore, the tone your last two essays are written in at least suggests that you're familiar with the concept of dealing some out:\r\n\r\nIn your paragraph \"Undefined values...\", you're not giving the creators of SQL, perl and python the benefit of the doubt. They didn't learn their lesson that the introduction of nil into a language is a mistake - period. Others might call this a design decision. A questionable one in your eyes - maybe, but oh well.\r\n\r\nThe reference post \"Python's lambda is broken!\" is basically a rant, ending with \"What were the implementors of Python thinking?!\". Considering that, you got many helpful replies pointing out the different implementations of closures in different languages.\r\n\r\nIf there is a way to read the complete last paragraph \"When should mistakes be discovered?\" other than a dichotomy between (static==secure) vs. (dynamic==flexible but less secure), tell me how to. It's difficult to not resolve the initial question into \"In languages written in dynamic languages, errors are discovered by the user.\"\r\n\r\nBut towards your question concerning \"Maybe\". \r\nA function returning \"Maybe Integer\" is basically returning a tuple of a potential return value (type Integer) plus the potential information that something bad happened. Of course it is absolutely possible to implement this kind of thing in ruby as Jules pointed out. But the very concept is already implemented in all major languages as Exception in the form of begin/rescue in ruby, or $x=f($y) or blah() in perl. But to ask how to enforce error handling up the call stack in a dynamic language is equivalent to \"tell me how to enforce types in a dynamic language\". You don't. \r\nThis leads us right back to the central question:\r\n\r\nDoes solidly implemented software that is reasonably well covered with tests get even more secure by formally enforcing a type system? After years of software development, starting in Eiffel, Java, C/C++ and now Ruby, JavaScript, C I have absolutely no reason to assume this.\r\n\r\nTherefore I consider it as a valid question of tastes (which is the least amount of religiosity I can offer :)."
email: 79115885290047cf976aa0e8f1cde6f1
