name: smallpaul
date: '2009-04-12 10:20:48'
url: ''
message: "&gt; There are probably other options. The first solution is horrible, as every Java programmer knows, because it leads to many NullPointerExceptions. The second solution is probably the most â€œobject-orientedly correctâ€\x9D but people find it impractical, as it spreads code around in two classes. When I taught java I lectured the third solution, but that one has the big disadvantage that the programmer is responsible for checking every time whether a tree is empty or not.\n\nWhat code does the EmptyTree class have? If we are emulating your Haskell example then all of these classes would have data and no code. Conversely, if we wanted to add code, we'd put it only on the NodeTree (given that the EmptyTree has no state and serves as simply a sentinel).\n\nYou can use these classes as almost exactly the same as Haskell's constructors and the consumer will be forced to cast to the right subclass (as in Haskell) before they fish out a value or a child node. The only issue is that the consumer must use instanceof before the cast rather than doing both in the same expression as Haskell does. Still, that's not a huge issue.\n\n&gt; we add a fourth attribute empty of type boolean which tells us whether the tree is empty\n\n&gt;  When I taught java I lectured the third solution, but that one has the big disadvantage that the programmer is responsible for checking every time whether a tree is empty or not.\n\nIf you use this solution, then what do the \"right\" and \"left\" properties return?\n\nWhy is it easier or better to check for \"is_empty\" than to check \"==null\"? As long as the responsibility to check is on the programmer, what's the difference?"
email: 6ed7188a723fde4eb7917874e7672352
