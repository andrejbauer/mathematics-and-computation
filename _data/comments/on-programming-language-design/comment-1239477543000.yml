name: Jason Baker
date: '2009-04-11 21:19:03'
url: 'http://jasonmbaker.wordpress.com'
message: "I don't know how to respond to this other than to say that Python's philosophy doesn't match yours.  As CAR Hoare said:\r\n\r\n\"I conclude that there are two ways of constructing a software design:  One way is to make it so simple that there are obviously no deficiencies, the other way is to make it so complicated there are no obvious deficiencies.\"\r\n\r\nPython definitely encourages the former.  To steal a quote from Perl, does the language give you enough rope to hang yourself with?  Sure.  But python is so simple a language that these kinds of stupid mistakes are usually pretty easy to spot.\r\n\r\nHaskell's designers seem to disagree.  Peyton Jones once said that \"any language large enough to be useful must be dauntingly complex.\"\r\n\r\nTake the piece of code you post:\r\n\r\n    def f(n): return i + n\r\n\r\nThe problem is that based on this piece of code, we *don't know* if i is in scope or not.  The above code becomes valid if it's placed in this context:\r\n\r\n    def g():\r\n        i = 0\r\n        def f(n): return i + n\r\n        return f\r\n\r\nAre there ways to allow this behavior *and* remove the possibility of stupid mistakes?  Sure.  But not without adding several layers of complexity to the language.  Does that mean it's bad?  Not necessarily.  But then we go back to the dichotomy: do you encourage reliable code through simplicity or do you create reliability through better compiler checks?\r\n\r\nI'm of the belief that compiler checks don't eliminate or even reduce programmer stupidity.  They just make it go deeper by creating complexity.  Have I written my fair share of stupid python code?  Sure.  But it's rare that I ever find myself saying \"WTF is this code doing?\"\r\n\r\nBut you obviously view things differently and that's a good thing."
email: b8e26b9942e7193a4fe32c407aacfef5
