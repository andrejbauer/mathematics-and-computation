name: Fritz Ruehr
date: '2009-04-12 06:57:11'
url: ''
message: "Thanks for a concise but thorough summary of important issues.\n\nRegarding your example of binary search trees, there are some interesting recent alternatives to Coq and Agda for enforcing these sorts of constraints. I am thinking specifically of <a href=\"http://sage.soe.ucsc.edu/\" rel=\"nofollow\">the Sage language</a> from Cormac Flanagan and his students at UC Santa Cruz (also Steve Freund at Williams); I heard about it from Aaron Tomb during a recent tech talk at Galois. In their tech report <a href=\"http://sage.soe.ucsc.edu/sage-tr.pdf\" rel=\"nofollow\">Sage: Uniï¬\x81ed Hybrid Checking for First-Class Types, General Reï¬\x81nement Types, and Dynamic</a>, they in fact use binary search trees as a motivating example (quoting from their Section 2.1): \n\n<blockquote>\nNote that Sage supports dependent function types, and so the type of the third argument to search can depend on the values of the ï¬\x81rst and second arguments.\n\n...\n\nThe Sage compiler uses an automatic theorem prover to statically verify that the specified ordering invariants on binary search trees are satisfied by these two functions -- no run-time checking is required.\n\n...\n\nThis precisely-typed BST implementation can inter-operate cleanly with dynamically-typed client code, while still preserving the ordering invariant on BSTs.\n</blockquote>\n\nSage constitutes an interesting design which manages to accommodate dependent types in a statically-typed setting; I'd be interested in hearing your opinion of it. \n\nOh, and a PS to Bob Harper: the \"one true type that everything must have\", is that the One True Type that in the Darkness Binds Them? (at run-time, presumably :) )"
email: 7c0834d56bf1fb4644a1f1d652d2433c
