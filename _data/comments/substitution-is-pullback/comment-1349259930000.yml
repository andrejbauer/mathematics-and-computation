name: Paul Taylor
date: '2012-10-03 12:25:30'
url: 'http://www.paultaylor.eu'
message: "Here is a programming problem that arises from the above description of the category: <b>what is the appropriate datastructure for morphisms?</b>\n\nThe lazy definition of a morphism is that it is an assignment of terms to variables, ie what is known as an <b>environment</b> in compiler design.\n\nTraditionally, <a href=\"http://paultaylor.eu/algorithms/hash\" rel=\"nofollow\"><b>hash tables</b></a> were used to do this, but this is a monolithic solution based on assuming that there is only one environment to be considered. It works in practice because it can be updated in place and previous versions of the environment will not be needed again.\n\nIn a category there are morphisms every which way.  We would also like to think of this problem in a <b>functional</b> way. There need to be multiple versions of the environment.\n\nOne of the operations that needs to be done on this datastructures is <b>composition</b>, whilst clearly the generating maps $\\hat x$ and $[a/x]$ need to be represented, so in the first instance we use this representation.\n\nFrom this we obtain the term that is to be assigned to a variable $x$ by reading the string of generators backwards from target to source. (Substitution is a <b>contravariant action</b>.)\n\n-- If we encounter a generator $[a/x]$ then $a$ is the required term, except that it contains its own free variables, which may each need to be substituted using assignments that are further back in the string.\n\n-- If instead we encounter $\\hat x$ then there is an error, because this means that $x$ is <b>excluded</b> from the target context.\n\nThis is a <b>linear search</b>, which is expensive if the morphism is the composite of a very long string.  This situation arises in the compilation of an ordinary program during reading of the hundreds of definitions that might be present in the library headers and leads to the use of hashes.\n\nThere are other datastructures that can be used for dictionary-like data in a functional way. There is a <a href=\"http://www.cambridge.org/gb/knowledge/isbn/item1161740/?site_locale=en_GB\" rel=\"nofollow\">book by Chris Okasaki</a> about them. One idea that might be adapted to this problem is that of <a href=\"http://en.wikipedia.org/wiki/Redâ€“black_tree\" rel=\"nofollow\"><b>red-black trees</b></a>.\n\nThis problem is more complex than dictionary search because we need to know that neither $[a/x]$ nor $\\hat x$ occurs in the right-hand sub-tree that arises from composition (in diagrammatic order) before we select an occurrence from the other sub-tree. So the items in the dictionary have both an \"alphabetical\" order that we use to search for them quickly and also the order in which they occur in the composite, from which we require the right-most."
email: 24674efd7c9de6dad323b394fbdf2ebd
