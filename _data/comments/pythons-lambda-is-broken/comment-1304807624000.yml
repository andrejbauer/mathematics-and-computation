name: Frank Atanassow
date: '2011-05-08 00:33:44'
url: 'http://profiles.google.com/blackheart2'
message: "I know this discussion is long since over, but I recall talking about the very same issue recently on somebody else's blog and, as far as I can see, all the explanations here are incorrect. (All the ones there were too; it's tricky.) The issue is not scoping or broken lambda-expressions; rather, it depends on the fact that Python implements list comprehensions via mutation.\n\nFor my reference and yours, here is your first example:\n\n<code>\n&gt;&gt;&gt; fs = [(lambda n: i + n) for i in range(10)]\n&gt;&gt;&gt; fs[3](4)\n13\n</code>\n\nWhen the lambda-expression is evaluated, the variable <code>i</code> is properly captured in a closure. In Python, a variable is, as you know, a reference to a mutable cell. However, Python list comprehension is evaluated by updating <code>i</code> for each element in the domain, not rebinding it. This means that you are creating 10 closures with 10 copies of references to the same mutable cell. By the time <code>fs</code> is bound, the comprehension has been evaluated, so the value in the cell is 10, so each dereference will return 10.\n\nIn contrast, in Ocaml the <code>for-do</code> construct is implemented by rebinding the index for each evaluation of the body. However, if you were to implement list comprehensions using camlp4 in the same way as Python, by mutation, you might encounter the same problem in Ocaml, depending on whether you you capture the cell or its contents.\n\nThis code, which is the natural and erroneous solution:\n\n<code>\n[ (fun n -&gt; !i + n) for i in 1 to 10]\n</code>\n\nwould behave like the Python code, because the cell is captured and only dereferenced after the list is built.\n\nThis code:\n\n<code>\n[ let i' = !i in (fun n -&gt; i' + n) for i in 1 to 10 ]\n</code>\n\nwould behave as you expected, because <code>i</code> is dereferenced while the list is being built.\n\nI don't know if Python provides a way to get the same effect (I am a Haskeller); it displays the usual imperative confusion between variables and cells. But I think I've demonstrated that, at least in this respect, Python's lambda does not behave any differently than you would expect an ML language's to behave."
email: f774682b37e24d7bbebcd92ec1f1453e
