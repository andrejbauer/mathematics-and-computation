---
author: admin
title: "\n\t\t\t\tHow to implement an LCF-style proof-assistant\t\t"
slug: '-how-to-implement-an-lcf-style-proof-assistant-'
id: 1932
date: '2016-08-11 08:46:09'
layout: draft
categories:
  - General
---

You're almost right, except that these "smart constructors" do something: they output the conclusion of the derivation (and the only way to generate conclusions is by using the smart constructors). Let's do an example which is *not* Martin-Löf type theory, say the fragment of propositional calculus with truth, implication, and conjunction. We are going to do it in natural deduction style. Let me also fix terminology: * the **formulas* are the things built from propositional letters $A, B, C, \ldots$, the constant $\top$ and the connectives $\land$ and $\Rightarrow$. * a **statement** has the form $\psi_1, \ldots, \psi_n \vdash \phi$ where $\psi_i$ and $\phi$ are formulas. We call the $\psi_i$'s the *hypotheses*, and $\phi$ the *conclusion*. * a **derivation** is a tree which shows how to derive a statement by using the usual inference rules. Note: there are no "proof terms", and derivations derive statements, not formulas. An LCF-style proof checker is a general-purpose programming language with several special features. First, it has the following datatypes: * a datatype `formula` for representing formulas * a datatype `statement` for representing statements Second, we control how values of datatype`statement` may be generated by making `statement` an [*abstract* datatype](http://homepages.inf.ed.ac.uk/stg/NOTES/node79.html). This means that we allow the construction of statements *only* by means of functions and values we provide. In our case the constructors would correspond to the usual natural-deduction rules (below it is understood that formulas and statements are values of datatypes `formula` and `statement` respectively, even though I write them as mathematical formulas): * a constructor `true_intro : formula list -> statement` which accepts a list of formulas $[A_1, \ldots, A_n]$ and outputs the statement $A_1, \ldots, A_n \vdash \top$ * a constructor `hypothesis : formula list -> int -> statement` which accepts a list of formulas $[A_1, \ldots, A_n]$ and an integer $m$, verifies that $1 \leq m \leq n$ and outputs $A_1, \ldots, A_\n \vdash A_m$ * a constructor `and_intro : statement -> statement -> statement` which accepts two statements $\Gamma \vdash A$ and $\Delta \vdash B$, verifies that $\Gamma = Delta$, and outputs $\Gamma \vdash A \land B$ * a constructor `and_elim1 : statement -> statement` which accepts a statement, verifies that it is of the form $\Gamma \vdash A \land B$, and outputs $\Gamma \vdash A$. * similarly, a constructor `and_elim2`, * a constructor `imply_intro : statement -> statement` which accepts a statement $A_1, \ldots, A_n \vdash B$, verifies that $n > 0$, and outputs $A_2, \ldots, A_n \vdash A \Rightarrow B$ * a constructor `imply_elim : statement -> statement -> statement` which accepts statements $\Gamma \vdash A$, $\Delta \vdash B$, verifies that $\Gamma = \Delta$, verifies that $A$ equals $B \Rightarrow C$ for some $C$, and outputs $\Gamma \vdash C$. Above, if any verification fails, the constuctor reports and error, say by throwing an exception. If we use a sane programming language (such as SML or OCaml, both of which descend from the original ML of Edinburgh LCF!) then we should be able to prove: > **Soundness theorem:** if a program `p` evaluates to a value `v` of type `statement` then `v` is a valid representation of a statement $\Gamma \vdash A$ *and* there exists a derivation of $\Gamma \vdash A$. Observe that the derivations themselves do *not* form a datatype and they are *not* stored in memory. We can also hope to prove > **Completeness theorem:** if $\Gamma \vdash A$ is derivable then there is a program `p` which evaluates to a value representing $\Gamma \vdash A$. In any case, the user is now free to implement arbitrarily complex tactics for deriving statements. They can be sure that they can never introduce a bug that will cause an underivable statement to be derived (but of course there are other kinds of bugs). Now, in Martin-Löf type theory we have a special theorem: > **Theorem:** there is an algorithm which decides whether $\Gamma \vdash e : A$ is derivable.